import JSZip from 'jszip'

// ─── SVG Export ───

/**
 * Generate SVG string from tool contour points (2D outline in mm)
 * @param {Array<{x,y}>} toolPoints - scaled tool contour points in mm
 * @param {Object} config - export config from buildConfig()
 * @returns {string} SVG file content
 */
export function exportSVG(toolPoints, config) {
  const allContours = getAllContours(toolPoints, config)
  const bounds = getBounds(allContours.flat())

  const padding = 5
  const width = bounds.maxX - bounds.minX + padding * 2
  const height = bounds.maxY - bounds.minY + padding * 2
  const offsetX = -bounds.minX + padding
  const offsetY = -bounds.minY + padding

  let paths = ''

  allContours.forEach((pts, i) => {
    const d = pts.map((p, j) => {
      const cmd = j === 0 ? 'M' : 'L'
      return `${cmd}${(p.x + offsetX).toFixed(3)},${(p.y + offsetY).toFixed(3)}`
    }).join(' ') + ' Z'

    const color = i === 0 ? '#E8650A' : '#FF8C42'
    paths += `  <path d="${d}" fill="none" stroke="${color}" stroke-width="0.3" />\n`
  })

  // Add finger notch outlines if present
  if (config.fingerNotches && config.fingerNotches.length > 0) {
    config.fingerNotches.forEach(fn => {
      const notchPath = getNotchOutline(fn, offsetX, offsetY)
      if (notchPath) {
        paths += `  <path d="${notchPath}" fill="none" stroke="#4488FF" stroke-width="0.2" stroke-dasharray="1,1" />\n`
      }
    })
  }

  return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     width="${width.toFixed(2)}mm" height="${height.toFixed(2)}mm"
     viewBox="0 0 ${width.toFixed(2)} ${height.toFixed(2)}">
  <!-- Generated by TracetoForge - dimensions in mm -->
  <title>TracetoForge Tool Outline</title>
${paths}</svg>`
}


// ─── DXF Export ───

/**
 * Generate DXF string from tool contour points (2D outline in mm)
 * @param {Array<{x,y}>} toolPoints - scaled tool contour points in mm
 * @param {Object} config - export config from buildConfig()
 * @returns {string} DXF file content
 */
export function exportDXF(toolPoints, config) {
  const allContours = getAllContours(toolPoints, config)
  let entities = ''

  allContours.forEach((pts, contourIdx) => {
    const layerName = contourIdx === 0 ? 'TOOL_0' : `TOOL_${contourIdx}`

    // LWPOLYLINE entity
    entities += '  0\nLWPOLYLINE\n'
    entities += '  8\n' + layerName + '\n'     // layer
    entities += '  62\n' + (contourIdx === 0 ? '30' : '40') + '\n' // color (orange shades)
    entities += '  90\n' + pts.length + '\n'   // vertex count
    entities += '  70\n1\n'                     // closed polyline

    pts.forEach(p => {
      entities += '  10\n' + p.x.toFixed(4) + '\n'  // X
      entities += '  20\n' + p.y.toFixed(4) + '\n'  // Y
    })
  })

  // Add finger notch outlines
  if (config.fingerNotches && config.fingerNotches.length > 0) {
    config.fingerNotches.forEach((fn, ni) => {
      const notchPts = getNotchPoints(fn)
      if (notchPts && notchPts.length > 0) {
        entities += '  0\nLWPOLYLINE\n'
        entities += '  8\nNOTCH_' + ni + '\n'
        entities += '  62\n5\n'  // blue
        entities += '  90\n' + notchPts.length + '\n'
        entities += '  70\n1\n'

        notchPts.forEach(p => {
          entities += '  10\n' + p.x.toFixed(4) + '\n'
          entities += '  20\n' + p.y.toFixed(4) + '\n'
        })
      }
    })
  }

  return `  0
SECTION
  2
HEADER
  9
$INSUNITS
  70
4
  9
$MEASUREMENT
  70
1
  0
ENDSEC
  0
SECTION
  2
TABLES
  0
TABLE
  2
LAYER
  0
LAYER
  2
TOOL_0
  70
0
  62
30
  6
CONTINUOUS
  0
ENDTAB
  0
ENDSEC
  0
SECTION
  2
ENTITIES
${entities}  0
ENDSEC
  0
EOF`
}


// ─── 3MF Export ───

/**
 * Generate 3MF file (zip containing XML) from the STL geometry buffer
 * 3MF is essentially a zip file with an XML model description
 * @param {ArrayBuffer} stlBuffer - the already-generated STL binary buffer
 * @param {Array<{x,y}>} toolPoints - scaled tool contour points
 * @param {Object} config - export config
 * @returns {Promise<Blob>} 3MF file as a Blob
 */
export async function export3MF(stlBuffer, toolPoints, config) {
  // Parse triangles from the STL buffer to build 3MF mesh XML
  const { vertices, triangles } = parseSTLBuffer(stlBuffer)

  const modelXml = build3MFModelXml(vertices, triangles)

  const zip = new JSZip()

  // 3MF required structure
  zip.file('[Content_Types].xml',
    `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`)

  zip.file('_rels/.rels',
    `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`)

  zip.file('3D/3dmodel.model', modelXml)

  const blob = await zip.generateAsync({ type: 'blob', mimeType: 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml' })
  return blob
}


// ─── Multi-format ZIP bundler ───

/**
 * Bundle multiple export formats into a single zip
 * @param {Object} files - { 'filename.stl': ArrayBuffer|Blob|string, ... }
 * @returns {Promise<Blob>}
 */
export async function bundleAsZip(files) {
  const zip = new JSZip()
  for (const [name, content] of Object.entries(files)) {
    zip.file(name, content)
  }
  return await zip.generateAsync({ type: 'blob' })
}


// ─── Helper Functions ───

/**
 * Get all tool contours (primary + additional tools) as arrays of mm-scaled points
 */
function getAllContours(toolPoints, config) {
  const contours = [toolPoints]

  if (config.additionalTools && config.additionalTools.length > 0) {
    config.additionalTools.forEach(t => {
      if (t.points && t.points.length >= 3) {
        // Apply tool offset
        const offsetPts = t.points.map(p => ({
          x: p.x + (t.toolOffsetX || 0),
          y: p.y + (t.toolOffsetY || 0)
        }))
        contours.push(offsetPts)
      }
    })
  }

  return contours
}

/**
 * Get bounding box of all points
 */
function getBounds(points) {
  return points.reduce(
    (acc, p) => ({
      minX: Math.min(acc.minX, p.x),
      maxX: Math.max(acc.maxX, p.x),
      minY: Math.min(acc.minY, p.y),
      maxY: Math.max(acc.maxY, p.y)
    }),
    { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity }
  )
}

/**
 * Generate SVG path data for a finger notch outline
 */
function getNotchOutline(fn, offsetX, offsetY) {
  const pts = getNotchPoints(fn)
  if (!pts || pts.length < 2) return null

  return pts.map((p, j) => {
    const cmd = j === 0 ? 'M' : 'L'
    return `${cmd}${(p.x + offsetX).toFixed(3)},${(p.y + offsetY).toFixed(3)}`
  }).join(' ') + ' Z'
}

/**
 * Get 2D outline points for a finger notch shape
 */
function getNotchPoints(fn) {
  if (!fn) return null

  const cx = fn.x || 0
  const cy = fn.y || 0

  if (fn.shape === 'circle' || fn.shape === 'semicircle') {
    const r = fn.radius || 10
    const pts = []
    const segments = 24
    const startAngle = fn.shape === 'semicircle' ? 0 : 0
    const endAngle = fn.shape === 'semicircle' ? Math.PI : Math.PI * 2

    for (let i = 0; i <= segments; i++) {
      const angle = startAngle + (endAngle - startAngle) * (i / segments)
      pts.push({
        x: cx + r * Math.cos(angle),
        y: cy + r * Math.sin(angle)
      })
    }
    return pts
  }

  if (fn.shape === 'rectangle') {
    const w = (fn.w || 20) / 2
    const h = (fn.h || 10) / 2
    return [
      { x: cx - w, y: cy - h },
      { x: cx + w, y: cy - h },
      { x: cx + w, y: cy + h },
      { x: cx - w, y: cy + h }
    ]
  }

  return null
}

/**
 * Parse binary STL buffer to extract vertices and triangle indices
 */
function parseSTLBuffer(buffer) {
  const view = new DataView(buffer)
  const numTriangles = view.getUint32(80, true)

  // Use a map to deduplicate vertices
  const vertexMap = new Map()
  const vertices = []
  const triangles = []

  let offset = 84
  for (let i = 0; i < numTriangles; i++) {
    // Skip normal (12 bytes)
    offset += 12

    const triIndices = []
    for (let v = 0; v < 3; v++) {
      const x = view.getFloat32(offset, true); offset += 4
      const y = view.getFloat32(offset, true); offset += 4
      const z = view.getFloat32(offset, true); offset += 4

      // Round to avoid floating point key issues
      const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`

      if (!vertexMap.has(key)) {
        vertexMap.set(key, vertices.length)
        vertices.push({ x, y, z })
      }
      triIndices.push(vertexMap.get(key))
    }

    triangles.push(triIndices)
    offset += 2 // attribute byte count
  }

  return { vertices, triangles }
}

/**
 * Build 3MF model XML from vertices and triangles
 */
function build3MFModelXml(vertices, triangles) {
  let verticesXml = ''
  vertices.forEach(v => {
    verticesXml += `          <vertex x="${v.x.toFixed(6)}" y="${v.y.toFixed(6)}" z="${v.z.toFixed(6)}" />\n`
  })

  let trianglesXml = ''
  triangles.forEach(t => {
    trianglesXml += `          <triangle v1="${t[0]}" v2="${t[1]}" v3="${t[2]}" />\n`
  })

  return `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02"
       xmlns:slic3rpe="http://schemas.slic3r.org/3mf/2017/06">
  <metadata name="Application">TracetoForge</metadata>
  <resources>
    <object id="1" type="model">
      <mesh>
        <vertices>
${verticesXml}        </vertices>
        <triangles>
${trianglesXml}        </triangles>
      </mesh>
    </object>
  </resources>
  <build>
    <item objectid="1" />
  </build>
</model>`
}
